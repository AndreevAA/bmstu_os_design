# bmstu_os_design

## peterson with conflics

Источники: https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9F%D0%B5%D1%82%D0%B5%D1%80%D1%81%D0%BE%D0%BD%D0%B0#:~:text=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%20%D0%9F%D0%B5%D1%82%D0%B5%D1%80%D1%81%D0%BE%D0%BD%D0%B0%20%E2%80%94%20%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%20%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F,%D0%BE%D0%B1%D0%BE%D0%B1%D1%89%D1%91%D0%BD%20%D0%B4%D0%BB%D1%8F%20%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%BA%D0%BE%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B0%20%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2.

Алгоритм Петерсона — это классический алгоритм для синхронизации процессов, который обеспечивает взаимное исключение для двух потоков. Он был разработан, чтобы решить проблему контроля доступа к общему ресурсу без необходимости использования стандартных средств синхронизации, таких как мьютексы или семафоры, и подходит для работы в средах с многозадачностью.

Основные понятия:

Взаимное исключение: гарантирует, что в данный момент времени только один поток может выполнять критическую секцию.

Локальные переменные: используются для указания, хочет ли поток войти в критическую секцию (флаг) и чтобы определить, чей черед заходить в критическую секцию (идентификатор потока).

Критическая секция: участок кода, который обращается к общему ресурсу.

Алгоритм
- Каждый поток устанавливает свой флаг в true, указывая, что он желает войти в критическую секцию.
- Поток устанавливает значение переменной, указывающей, какой поток может входить в критическую секцию (сигнализирует о том, что сейчас его очередь).
- Затем поток проверяет, разрешен ли ему вход в критическую секцию. Если нет, он ждет.
- Когда поток завершает работу в критической секции, он сбрасывает свой флаг.

Работа программы:
- Инициализация: Мы создаем массив want, который использует индексы потоков для обозначения, хочет ли он войти в критическую секцию. Переменная turn указывает, чей сейчас ход.
- Функция потока (thread_function): Каждый поток проходит 5 итераций, пытаясь получить доступ к критической секции. Внутри критической секции он просто выводит сообщение и спит в течение 1 секунды для имитации работы.
- Синхронизация: Используются два массива want и turn, чтобы контролировать доступ к критической секции.

Проблемы: В реальных системах этот алгоритм может не работать, если потоки выполняются на разных процессорах, так как достаточно больших задержек и оптимизаций. Однако, это хороший учебный пример.
Расширения: Вы можете модифицировать код для работы с большим количеством потоков или добавить больше логики для работы с доками и очередями.


! Требуется автоматизация. Должно быть много тестов. 
Каждый поток делает 10 млн циклов например.
Если автоматизация показывасет конфликт, то пусть выводит ее.
Вероятность увидеть ошибке низка.

Увеличить вероятность срабатываения ошибки.
компилятор должен не совсем убить цкил.

Цикл хотя бы несколько десятков секунд крутилось.

Все параметры вывести в дефайн.

2. Пример механизма синхронизации повторного чтения. Запись не так часто, а чтение многократно.

Длительность ожидания подбирать.

Время ожидания должно соотвествовать тому, что в enter() leave()

Атомарная инструкция sync fetching int.

Должны быть 2 смежные инструкции, между которыми процессор зависнет.

Может между ними инструкция компилятора затешится.

Это вопрос стечения обстоятельств.

Искать с разными режимами оптимизации.


? У современных интелов есть способы работы с RTR памятью. Идеология барьеров более понятная. Ускорениея не увидел.