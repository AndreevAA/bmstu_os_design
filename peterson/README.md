# bmstu_os_design

### Источники
[Алгоритм Петерсона — Википедия](https://ru.wikipedia.org/wiki/Алгоритм_Петерсона#:~:text=Алгоритм%20Петersona%20%E2%80%94%20алгоритм%20параллельного%20программирования,%D0%BE%D0%B1%D0%BE%D0%B1%D1%89%D1%91%D0%BD%20%D0%B4%D0%BB%D1%8F%20%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%BA%D0%BE%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B0%20%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2.)

### Алгоритм Петерсона

Алгоритм Петерсона — это классический алгоритм для синхронизации процессов, который обеспечивает взаимное исключение для двух потоков. Он подходит для работы в средах с многозадачностью и предназначен для контроля доступа к общему ресурсу без использования стандартных средств синхронизации.

#### Основные понятия

- **Взаимное исключение**: Гарантирует, что в данный момент времени только один поток может выполнять критическую секцию.
- **Локальные переменные**: Используются, чтобы указать, хочет ли поток войти в критическую секцию (флаг) и определить, чей черед заходить в критическую секцию (идентификатор потока).
- **Критическая секция**: Участок кода, который обращается к общему ресурсу.

#### Алгоритм

1. Каждый поток устанавливает свой флаг в `true`, указывая, что он желает войти в критическую секцию.
2. Поток устанавливает значение переменной, указывающей, какой поток может входить в критическую секцию.
3. Поток проверяет, разрешен ли ему вход в критическую секцию. Если нет, он ждет.
4. Когда поток завершает работу в критической секции, он сбрасывает свой флаг.

#### Работа программы

- **Инициализация**: Создается массив `want`, который использует индексы потоков для обозначения желания доступа к критической секции. Переменная `turn` указывает, чей сейчас ход.
- **Функция потока (thread_function)**: Каждый поток выполняет заданное количество итераций. В каждой итерации он пытается получить доступ к критической секции, выводит сообщение о входе и выходе из нее.
- **Синхронизация**: Используются массивы `want` и переменная `turn` для контроля доступа к критической секции.

### Проблемы

В реальных системах алгоритм может не работать на разных процессорах из-за задержек и оптимизаций компилятора. Тем не менее, это хороший учебный пример. 

### Расширения

- **Автоматизация**: Для повышения надежности необходимо добавить много тестов. Каждый поток должен делать 10 миллионов итераций, чтобы повысить вероятность конфликтов.
- **Обработка конфликтов**: При обнаружении конфликтов программа должна выводить сообщение об ошибке.
- **Изменения в ожидании**: Длительность ожидания должна соответствовать значениям `enter()` и `leave()`.
  
### Дополнительные примеры

1. **Механизм синхронизации повторного чтения**: Реализуйте алгоритм, в котором запись производится реже, а чтение — многократно.
  
2. **Использование атомарных инструкций**: Реализуйте подход, использующий атомарные инструкции для предотвращения конфликтов при чтении и записи.

### Ожидания и оптимизация

- Важно тестировать алгоритм с разными уровнями оптимизации компилятора, чтобы понять, как это влияет на возможность возникновения конфликтов.

### Примечание

Не забудьте протестировать алгоритм на различных архитектурах и настроить параметры для достижения лучших результатов.